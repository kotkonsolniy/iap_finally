Контрольные вопросы по курсу.

Каждому достается 2 теоретических + 1 практический вопрос. 

Теоретические:
1. Модели ЭМВОС, ISO/OSI и TCP/IP. Протоколы TCP и UDP. Назначение и отличия. Сокеты, сырые сокеты
2. Анализ пакетов в Windows и Linux. Модули ctypes и struct. 
3. Конкурентность и параллелизм. Узкие места в работе программы:  I/O-bound и CPU-bound. Характеристика и способы ускорения.  Типы многозадачности. GIL.
4. Многопоточность. Тип многозадачности. Влияние  GIL. Когда применять? Отличия от асинхронности и многопроцессности. Описание библиотеки и её основных методов.
5. Асинхронность. Блокирующие и неблокирующие вызовы. Тип многозадачности. Влияние  GIL. Когда применять? Отличия от многопоточности и многопроцессности. Описание библиотеки и её основных методов. Старый и новый синтаксисы.
6. Многопроцессность. Тип многозадачности. Влияние  GIL. Когда применять? Отличия от многопоточности и асинхронности. Описание библиотеки и её основных методов.\
7. Генераторы, итераторы и итерируемые объекты. Назначение  и отличия. Создание генераторов и итераторов. Делегирование генераторов. Преимущества использования генераторов. Генераторные выражения.


Практические вопросы:
- реализация  TCP-клиента и TCP-сервера
- реализация UDP-клиента и UDP-сервера
- декодирование IP-пакетов
- декодирование TCP и UDP пакетов
- декодирование ICMP-пакетов
- работа с модулем ctypes
- работа с модулем struct
- вычисление подсети по маске
- привести пример блокирующих и неблокирующих вызовов.
- написание многопоточной программы
- написание "многопропроцессной" программы
- написание асинхронной программы

Написание программ должно сопровождаться созданием и активацией виртуального окружения, логированием и работой с аргументами командной строки.


### 1. Модели ЭМВОС, ISO/OSI и TCP/IP. Протоколы TCP и UDP. Назначение и отличия. Сокеты, сырые сокеты

**Модели ЭМВОС и ISO/OSI:**

- **ЭМВОС** — Экспериментальная модель взаимодействия открытых систем, предшественник модели OSI.
    
- **ISO/OSI (Open Systems Interconnection)** — модель из 7 уровней:
    
    1. Физический (Physical)
        
    2. Канальный (Data Link)
        
    3. Сетевой (Network)
        
    4. Транспортный (Transport)
        
    5. Сеансовый (Session)
        
    6. Представительский (Presentation)
        
    7. Прикладной (Application)  
        Модель OSI — теоретическая, используется для описания и стандартизации сетевых процессов.
        

**Модель TCP/IP:**

- Практическая модель, использующая 4 уровня:
    
    1. Сетевой интерфейс (Link)
        
    2. Интернет (Internet)
        
    3. Транспорт (Transport)
        
    4. Прикладной (Application)
        
- В основе лежит протокол IP, а на транспортном уровне — TCP и UDP.
    

**Протоколы TCP и UDP:**

- **TCP (Transmission Control Protocol):**
    
    - Надежный, ориентирован на соединение
        
    - Обеспечивает контроль ошибок, порядок доставки, подтверждения
        
    - Используется для HTTP, FTP, SMTP
        
- **UDP (User Datagram Protocol):**
    
    - Быстрый, без установления соединения (connectionless)
        
    - Нет гарантий доставки и порядка
        
    - Используется в потоковом видео, играх, DNS-запросах
        

**Сокеты и сырые сокеты:**

- **Сокеты** — программный интерфейс для сетевого взаимодействия, обычно работают с TCP и UDP.
    
- **Сырые сокеты (Raw sockets)** — позволяют работать на более низком уровне (IP-пакеты), дают возможность формировать собственные заголовки пакетов, нужны для реализации нестандартных протоколов или для анализа трафика.
    

---

### 2. Анализ пакетов в Windows и Linux. Модули ctypes и struct.

- **Анализ пакетов** — процесс перехвата и разбора сетевых пакетов.
    
- В **Windows** популярный инструмент — WinPcap/NPcap, в **Linux** — libpcap (tcpdump).
    
- **ctypes** — модуль Python для вызова функций из DLL/so, позволяет работать с низкоуровневыми структурами и API ОС.
    
- **struct** — для упаковки и распаковки бинарных данных (например, заголовков пакетов) в Python.
    

---

### 3. Конкурентность и параллелизм. Узкие места: I/O-bound и CPU-bound. Способы ускорения. Типы многозадачности. GIL.

- **Конкурентность** — умение системы справляться с несколькими задачами за один промежуток времени (не обязательно одновременно).
    
- **Параллелизм** — выполнение нескольких задач одновременно (на нескольких ядрах).
    
- **I/O-bound задачи:**
    
    - Ограничены операциями ввода/вывода (сетевые запросы, чтение с диска)
        
    - Ускорение: асинхронность, многопоточность (для ожидания I/O)
        
- **CPU-bound задачи:**
    
    - Ограничены вычислениями
        
    - Ускорение: многопроцессность (чтобы обойти GIL), оптимизация алгоритмов
        
- **Типы многозадачности:**
    
    - Многопоточность
        
    - Многопроцессность
        
    - Асинхронность
        
- **GIL (Global Interpreter Lock):**
    
    - Механизм в CPython, запрещающий одновременное выполнение байткода несколькими потоками, ограничивает параллелизм в CPU-bound задачах.
        

---

### 4. Многопоточность. Тип многозадачности. Влияние GIL. Когда применять? Отличия от асинхронности и многопроцессности. Описание библиотеки и методов.

- **Многопоточность** — несколько потоков внутри одного процесса, разделяют память.
    
- **Тип многозадачности:** конкурентная.
    
- **Влияние GIL:** Потоки не могут одновременно выполнять Python-код, но могут работать с I/O параллельно.
    
- **Когда применять:** для I/O-bound задач.
    
- **Отличия:**
    
    - Многопроцессность — отдельные процессы, больше памяти, обход GIL
        
    - Асинхронность — однопоточный, но неблокирующий код с event loop
        
- **Библиотека:** `threading`
    
- Основные методы: `Thread()`, `start()`, `join()`, `Lock()`
    

---

### 5. Асинхронность. Блокирующие и неблокирующие вызовы. Тип многозадачности. Влияние GIL. Когда применять? Отличия от многопоточности и многопроцессности. Описание библиотеки и методов. Старый и новый синтаксисы.

- **Асинхронность** — обработка задач с помощью неблокирующих вызовов и event loop.
    
- **Блокирующие вызовы:** останавливают выполнение программы до завершения операции (например, чтение с диска).
    
- **Неблокирующие вызовы:** позволяют выполнять другие задачи во время ожидания.
    
- **Тип:** конкурентная, однопоточная.
    
- **Влияние GIL:** минимально, т.к. код выполняется последовательно.
    
- **Когда применять:** I/O-bound задачи с большим количеством параллельных запросов.
    
- **Отличия:**
    
    - От многопоточности — без потоков и переключения контекста
        
    - От многопроцессности — без создания новых процессов
        
- **Библиотека:** `asyncio`
    
- Методы: `async def`, `await`, `asyncio.run()`, `asyncio.create_task()`
    
- **Синтаксис:**
    
    - Старый: `@asyncio.coroutine` + `yield from`
        
    - Новый: `async/await`
        

---

### 6. Многопроцессность. Тип многозадачности. Влияние GIL. Когда применять? Отличия от многопоточности и асинхронности. Описание библиотеки и методов.

- **Многопроцессность** — параллельное выполнение нескольких процессов.
    
- **Тип:** параллелизм.
    
- **Влияние GIL:** нет, т.к. процессы имеют отдельную память.
    
- **Когда применять:** CPU-bound задачи, требующие параллельных вычислений.
    
- **Отличия:**
    
    - От многопоточности — нет ограничения GIL, процессы изолированы
        
    - От асинхронности — физическое параллельное выполнение, большая нагрузка на память
        
- **Библиотека:** `multiprocessing`
    
- Методы: `Process()`, `start()`, `join()`, `Queue()`, `Pool()`
    

---

### 7. Генераторы, итераторы и итерируемые объекты. Назначение и отличия. Создание генераторов и итераторов. Делегирование генераторов. Преимущества генераторов. Генераторные выражения.

- **Итерируемые объекты:** объекты, по которым можно пройтись в цикле `for` (имеют метод `__iter__`).
    
- **Итераторы:** объекты с методом `__next__()`, который возвращает следующий элемент.
    
- **Генераторы:** упрощённый способ создания итераторов с помощью `yield`.
    
- **Создание генераторов:**
