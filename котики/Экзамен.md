# 1)
![[Pasted image 20250603222927.png]]![[Pasted image 20250603223008.png]]
![[Pasted image 20250603223114.png]]
TCP/IP (Transmission Control Protocol/Internet Protocol):
Представляет собой четырехуровневую модель взаимодействия в интернете.
Уровни: сетевой доступ, интернет, транспорт, прикладной.
Используется для описания взаимодействия между устройствами в интернете.
Протоколы TCP и UDP

TCP (Transmission Control Protocol):
Надежный протокол, обеспечивающий доставку данных в правильном порядке.
Использует механизм подтверждения получения данных (ACK).
Обеспечивает контроль потока и избегает переполнения сети.
Используется для передачи важных данных, требующих надежности.
UDP (User Datagram Protocol):
Ненадежный протокол, не обеспечивающий доставку данных в правильном порядке.
Не использует механизм подтверждения получения данных (ACK).
Обеспечивает быструю передачу данных, но без гарантии доставки.
Используется для передачи данных, требующих низкой задержки, таких как аудио и видео.

"""Сокеты и сырые сокеты"""

Сокеты:
Представляют собой программный интерфейс для взаимодействия между процессами или устройствами.
Обеспечивают двунаправленную передачу данных между процессами или устройствами.
Используются для реализации клиент-серверных приложений.
Сырые сокеты:
Представляют собой тип сокетов, который позволяет доступ к сетевым пакетам на уровне IP.
Обеспечивают доступ к сетевым пакетам без обработки протоколами TCP/IP.
Используются для реализации сетевых приложений, требующих низкоуровневого доступа к сетевым пакетам.
![[Pasted image 20250603230153.png]]
# 2)
**Анализ пакетов в Windows и Linux**

Анализ пакетов - это процесс изучения содержимого сетевых пакетов для понимания их структуры и содержания. Это может быть полезно для диагностики проблем с сетью, анализа трафика и выявления потенциальных угроз безопасности.
![[Pasted image 20250603230447.png]]
45 00 - начало протокола ip
![[Pasted image 20250603230514.png]]
![[Pasted image 20250603230543.png]]

**В Windows**

В Windows можно использовать следующие инструменты для анализа пакетов:

1. **Wireshark**: один из наиболее популярных анализаторов пакетов, который позволяет захватывать и анализировать сетевой трафик.
2. **Microsoft Network Monitor**: инструмент для анализа сетевого трафика, который позволяет захватывать и анализировать пакеты.
3. **Tcpdump**: консольный инструмент для анализа пакетов, который позволяет захватывать и анализировать сетевой трафик.

**В Linux**

В Linux можно использовать следующие инструменты для анализа пакетов:

1. **Tcpdump**: консольный инструмент для анализа пакетов, который позволяет захватывать и анализировать сетевой трафик.
2. **Wireshark**: также доступен в Linux и позволяет захватывать и анализировать сетевой трафик.
3. **Tshark**: консольный инструмент для анализа пакетов, который позволяет захватывать и анализировать сетевой трафик.
![[Pasted image 20250603230407.png]]
**Модули ctypes и struct**

В Python можно использовать модули `ctypes` и `struct` для анализа пакетов.

**ctypes**

Модуль `ctypes` позволяет работать с библиотеками, написанными на C, из Python. Это можно использовать для доступа к функциям, которые позволяют захватывать и анализировать пакеты.

**struct**

Модуль `struct` позволяет работать с байтовыми строками и преобразовывать их в структуры данных. Это можно использовать для анализа содержимого пакетов и извлечения необходимой информации.

**Модуль ctypes**

Модуль `ctypes` - это модуль Python, который позволяет работать с библиотеками, написанными на C, из Python. Это позволяет использовать функции и переменные, определенные в библиотеках C, в Python-программах.

**Основные возможности модуля ctypes**

1. **Вызов функций C**: модуль `ctypes` позволяет вызывать функции C из Python.
2. **Доступ к переменным C**: модуль `ctypes` позволяет доступ к переменным C из Python.
3. **Работа с структурами C**: модуль `ctypes` позволяет работать с структурами C из Python.
4. **Работа с массивами C**: модуль `ctypes` позволяет работать с массивами C из Python.

**Преимущества использования модуля ctypes**

1. **Возможность использования библиотек C**: модуль `ctypes` позволяет использовать библиотеки C в Python-программах.
2. **Увеличение производительности**: модуль `ctypes` позволяет вызывать функции C, которые могут быть более быстрыми, чем аналогичные функции Python.
3. **Возможность использования существующего кода**: модуль `ctypes` позволяет использовать существующий код C в Python-программах.

**Недостатки использования модуля ctypes**

1. **Сложность**: модуль `ctypes` может быть сложным в использовании, особенно для начинающих программистов.
2. **Небезопасность**: модуль `ctypes` может быть небезопасным, если не используется правильно.
3. **Зависимость от платформы**: модуль `ctypes` может зависеть от платформы, на которой он используется.
```python
from ctypes import Structure, c_ubyte, c_ushort, c_uint32
import socket
import struct

  
class IP(Structure):

    _fields_ = [
        ("ihl", c_ubyte, 4),
        ("version", c_ubyte, 4),
        ("tos", c_ubyte, 8),
        ("len", c_ushort, 16),
        ("id", c_ushort, 16),
        ("offset", c_ushort, 16),
        ("ttl", c_ubyte, 8),
        ("protocol_num", c_ubyte, 8),
        ("sum", c_ushort, 16),
        ("src", c_uint32, 32),
        ("dst", c_uint32, 32)
    ]

    def __new__(cls, socket_buffer=None):
        return cls.from_buffer_copy(socket_buffer)

    def __init__(self, socket_buffer=None):
        self.src_address = socket.inet_ntoa(struct.pack("<L", self.src))
        self.dst_address = socket.inet_ntoa(struct.pack("<L", self.dst))
```
![[Pasted image 20250603224851.png]]

```python
import struct

# Данные в little-endian порядке байтов

data = b'\x12\x34\x56\x78'

# Чтение байтов справа налево
print(struct.unpack('<I', data)) # Выводит (0x78563412,)

# Чтение байтов слева направо
print(struct.unpack('>I', data)) # Выводит (0x12345678,)
```
**Модуль struct**

Модуль `struct` - это модуль Python, который позволяет работать с байтовыми строками и преобразовывать их в структуры данных. Это позволяет читать и записывать данные в байтовом формате, что может быть полезно при работе с данными в компьютерных системах.

**Основные возможности модуля struct**

1. **Преобразование байтовых строк в структуры данных**: модуль `struct` позволяет преобразовывать байтовые строки в структуры данных, такие как целые числа, числа с плавающей точкой и строки.
2. **Преобразование структур данных в байтовые строки**: модуль `struct` позволяет преобразовывать структуры данных в байтовые строки.
3. **Чтение и запись данных в байтовом формате**: модуль `struct` позволяет читать и записывать данные в байтовом формате.

![[Pasted image 20250603225258.png]]

# 3)


**Конкурентность и параллелизм**

Конкурентность и параллелизм - это два понятия, которые часто используются в контексте программирования и компьютерных систем.

**Конкурентность**

Конкурентность - это способность программы или системы выполнять несколько задач одновременно, но не обязательно в одно и то же время. Конкурентность позволяет программе или системе использовать ресурсы более эффективно, но не обязательно увеличивает производительность.

**Параллелизм**

Параллелизм - это способность программы или системы выполнять несколько задач одновременно и в одно и то же время. Параллелизм позволяет программе или системе использовать несколько процессоров или ядер процессора для выполнения задач, что может увеличить производительность.

**Узкие места в работе программы**

Узкие места в работе программы - это места, где программа тратит больше всего времени и ресурсов. Узкие места могут быть связаны с вводом/выводом (I/O-bound) или с вычислениями (CPU-bound).
**Способы ускорения**

- **Оптимизация алгоритмов**: уменьшение количества операций или улучшение их эффективности.
- **Параллелизация**: выполнение нескольких задач одновременно.
- **Использование кэширования**: хранение часто используемых данных в быстрой памяти.
- **Использование специализированных процессоров**: использование процессоров, специализированных для выполнения определенных операций.
- **Уменьшение количества обращений к диску**: уменьшение количества операций чтения и записи на диск.
- **Использование асинхронных операций**: выполнение операций в фоновом режиме, не блокируя основной поток программы.
- **Использование многопоточной обработки**: обработка данных в нескольких потоках одновременно.
- **Использование распределенной обработки**: обработка данных на нескольких компьютерах одновременно.
![[Pasted image 20250603225413.png]]
**GIL**

GIL (Global Interpreter Lock) - это механизм, который используется в Python для синхронизации доступа к ресурсам. GIL блокирует доступ к ресурсам, пока один поток не завершит свою работу. Это может привести к снижению производительности в многопоточных приложениях.

Типы многозадачности:
Ассинхронность
Многопоточность
Многопроцессность
![[Pasted image 20250603230647.png]]

# 4)
**Многопоточность**

Многопоточность - это тип многозадачности, который позволяет программе или системе выполнять несколько потоков одновременно. Потоки - это легковесные процессы, которые могут быть выполнены одновременно.

**Влияние GIL**

GIL (Global Interpreter Lock) - это механизм, который используется в Python для синхронизации доступа к ресурсам. GIL блокирует доступ к ресурсам, пока один поток не завершит свою работу. Это может привести к снижению производительности в многопоточных приложениях.

**Когда применять**

Многопоточность можно применять в следующих случаях:

- **Выполнение задач, которые не требуют доступа к общим ресурсам**: если задачи не требуют доступа к общим ресурсам, то многопоточность может быть эффективным способом их выполнения.
- **Выполнение задач, которые требуют доступа к общим ресурсам, но не блокируют их**: если задачи требуют доступа к общим ресурсам, но не блокируют их, то многопоточность может быть эффективным способом их выполнения.

**Отличия от асинхронности и многопроцессности**

Многопоточность отличается от асинхронности и многопроцессности следующим образом:

- **Асинхронность**: асинхронность - это способность программы или системы выполнять задачи без блокировки основного потока программы. Асинхронность не требует создания отдельных потоков или процессов.
- **Многопроцессность**: многопроцессность - это способность программы или системы выполнять несколько процессов одновременно. Процессы - это более тяжелые, чем потоки, и требуют больше ресурсов.

**Описание библиотеки и её основных методов**

Библиотека `threading` - это библиотека Python, которая предоставляет поддержку многопоточности. Основные методы библиотеки `threading`:

- `Thread`: класс, который представляет поток.
- `start()`: метод, который запускает поток.
- `join()`: метод, который ожидает завершения потока.
- `run()`: метод, который выполняет поток.

Пример использования библиотеки `threading`:
```python
import threading

def task():
	print("Task started")
	# Выполнение задачи
	print("Task finished")

thread = threading.Thread(target=task)
thread.start()
thread.join()
```

# 5)
**Асинхронность**

Асинхронность - это тип многозадачности, который позволяет программе или системе выполнять задачи без блокировки основного потока программы. Асинхронность не требует создания отдельных потоков или процессов.

**Блокирующие и неблокирующие вызовы**

Блокирующие вызовы - это вызовы, которые блокируют основной поток программы до тех пор, пока не будет получен результат. Неблокирующие вызовы - это вызовы, которые не блокируют основной поток программы и позволяют ему продолжать выполнять другие задачи.

**Тип многозадачности**

Асинхронность - это тип многозадачности, который позволяет программе или системе выполнять задачи без блокировки основного потока программы.

**Влияние GIL**

GIL (Global Interpreter Lock) - это механизм, который используется в Python для синхронизации доступа к ресурсам. GIL блокирует доступ к ресурсам, пока один поток не завершит свою работу. Асинхронность не требует создания отдельных потоков или процессов, поэтому GIL не влияет на асинхронность.

**Когда применять**

Асинхронность можно применять в следующих случаях:

- **Выполнение задач, которые не требуют доступа к общим ресурсам**: если задачи не требуют доступа к общим ресурсам, то асинхронность может быть эффективным способом их выполнения.
- **Выполнение задач, которые требуют доступа к общим ресурсам, но не блокируют их**: если задачи требуют доступа к общим ресурсам, но не блокируют их, то асинхронность может быть эффективным способом их выполнения.

**Отличия от многопоточности и многопроцессности**

Асинхронность отличается от многопоточности и многопроцессности следующим образом:

- **Многопоточность**: многопоточность - это тип многозадачности, который требует создания отдельных потоков. Асинхронность не требует создания отдельных потоков или процессов.
- **Многопроцессность**: многопроцессность - это тип многозадачности, который требует создания отдельных процессов. Асинхронность не требует создания отдельных потоков или процессов.

**Описание библиотеки и её основных методов**

Библиотека `asyncio` - это библиотека Python, которая предоставляет поддержку асинхронности. Основные методы библиотеки `asyncio`:

- `async def`: ключевое слово, которое используется для определения асинхронной функции.
- `await`: ключевое слово, которое используется для ожидания результата асинхронной функции.
- `asyncio.run()`: функция, которая запускает асинхронную функцию.
- `asyncio.create_task()`: функция, которая создает задачу для асинхронной функции

Правила:
```python
# async def f(x):
#     y = await z(x) # Ok - `await` and `return` allowed in coroutines
#     return y

# async def g(x):
#     yield x # Ok

# async def m(x):
#     yield from gen(x) # No - syntaxError

# def m(x):
#     y = await z(x) # Still no - syntaxError (no `async def` here)
#     return y
```

В Python 3.5 и ранее использовался старый синтаксис для определения асинхронных функций:
```python
import asyncio

@asyncio.coroutine
def task():

print("Task started")

# Выполнение задачи
print("Task finished")
yield
```
В Python 3.6 и позже используется новый синтаксис для определения асинхронных функций:
```python
import asyncio

async def task():
	print("Task started")
	# Выполнение задачи
	print("Task finished")
```

# 6)
**Многопроцессность**

Многопроцессность - это тип многозадачности, который позволяет программе или системе выполнять несколько процессов одновременно. Процессы - это более тяжелые, чем потоки, и требуют больше ресурсов.

**Тип многозадачности**

Многопроцессность - это тип многозадачности, который требует создания отдельных процессов.

**Влияние GIL**

GIL (Global Interpreter Lock) - это механизм, который используется в Python для синхронизации доступа к ресурсам. GIL блокирует доступ к ресурсам, пока один поток не завершит свою работу. Многопроцессность не требует создания отдельных потоков, поэтому GIL не влияет на многопроцессность.

**Когда применять**

Многопроцессность можно применять в следующих случаях:

- **Выполнение задач, которые требуют больших ресурсов**: если задачи требуют больших ресурсов, то многопроцессность может быть эффективным способом их выполнения.
- **Выполнение задач, которые не требуют доступа к общим ресурсам**: если задачи не требуют доступа к общим ресурсам, то многопроцессность может быть эффективным способом их выполнения.

**Отличия от многопоточности и асинхронности**

Многопроцессность отличается от многопоточности и асинхронности следующим образом:

- **Многопоточность**: многопоточность - это тип многозадачности, который требует создания отдельных потоков. Многопроцессность требует создания отдельных процессов.
- **Асинхронность**: асинхронность - это тип многозадачности, который не требует создания отдельных потоков или процессов. Многопроцессность требует создания отдельных процессов.

**Описание библиотеки и её основных методов**

Библиотека `multiprocessing` - это библиотека Python, которая предоставляет поддержку многопроцессности. Основные методы библиотеки `multiprocessing`:

- `Process`: класс, который представляет процесс.
- `start()`: метод, который запускает процесс.
- `join()`: метод, который ожидает завершения процесса.
- `Queue`: класс, который представляет очередь для передачи данных между процессами.
- `Pipe`: класс, который представляет канал для передачи данных между процессами.

Пример использования библиотеки `multiprocessing`:
```python
import multiprocessing

def task():
	print("Task started")
	# Выполнение задачи
	print("Task finished")


if __name__ == "__main__":
process = multiprocessing.Process(target=task)
process.start()
process.join()
```
В этом примере создается процесс, который выполняет задачу `task`. Процесс запускается с помощью метода `start()`, а затем ожидается его завершение с помощью метода `join()`

# 7)
**Генераторы, итераторы и итерируемые объекты**

Генераторы, итераторы и итерируемые объекты - это три связанных понятия в Python, которые позволяют работать с последовательностями данных.

**Назначение и отличия**

- **Итерируемые объекты**: итерируемые объекты - это объекты, которые можно перебрать в цикле. Примерами итерируемых объектов являются списки, кортежи, словари и множества.
- **Итераторы**: итераторы - это объекты, которые позволяют перебрать итерируемые объекты. Итераторы сохраняют состояние перебора и позволяют получить следующий элемент последовательности.
- **Генераторы**: генераторы - это特殊ный тип итераторов, которые позволяют создавать последовательности данных на лету, без необходимости хранить все данные в памяти.

**Создание генераторов и итераторов**

Генераторы и итераторы можно создать с помощью функций и классов.

- **Функции-генераторы**: функции-генераторы - это функции, которые содержат ключевое слово `yield` и позволяют создавать генераторы.
- **Классы-итераторы**: классы-итераторы - это классы, которые реализуют методы `__iter__` и `__next__` и позволяют создавать итераторы.

**Делегирование генераторов**

Делегирование генераторов - это механизм, который позволяет передать управление генератором другому генератору или функции.

**Преимущества использования генераторов**

Генераторы имеют следующие преимущества:

- **Экономия памяти**: генераторы позволяют создавать последовательности данных на лету, без необходимости хранить все данные в памяти.
- **Увеличение производительности**: генераторы позволяют избежать создания лишних объектов и уменьшить время выполнения программы.

**Генераторные выражения**

Генераторные выражения - это специальный тип выражений, которые позволяют создавать генераторы в одну строку.

Пример использования генераторного выражения:
```python
gen = (x**2 for x in range(10))
for x in gen:
	print(x)
```

генераторы - это функции, возвращающие последовательность значений (итератор - это сущность, у которого есть дандер метод next и iter), но не хранят все элементы в памяти

Итератор в Python 3 — это объект, который реализует протокол итератора, то есть предоставляет два метода:

1. **`__iter__()`** — возвращает сам итератор. Этот метод необходим для того, чтобы объект можно было использовать в конструкциях вроде цикла `for`.
    
2. **`__next__()`** — возвращает следующий элемент последовательности. При достижении конца последовательности возбуждает исключение `StopIteration`.
    

```python
def count_up_to(n):  
    i = 1  
    while i <= n:  
        yield i  # Возвращает i и приостанавливает выполнение  
        i += 1  
  
  
gen = count_up_to(3)  
  
print(type(gen), gen)  
  
print(next(gen))  # отдаёт одно значение  
print(next(gen))  # отдаёт одно значение  
print(next(gen))  # отдаёт одно значение  
print(next(gen))  # выдаст ошибку, так как генератор отдаёт только до n включительно  
  
print([i for i in iter(gen)])  # отдаёт все оставшиеся значения в генераторе
```

Ленивые вычисления - едим слона по частям

```python
gen = count_up_to(3)  
for i in gen:  
    print(i)  
  
for i in gen:  
    print(i) # не будет выводить, так как дошли до конца
```

Генератор вычисляет значения на лету, только при запросе.

range отличается от генератора тем, что подходит только для чисел

Точно понять разницу между функциями, итераторами, генераторами, чем отличается range от такого же генератора

```python
def flatten(lst):  
    for item in lst:  
        if isinstance(item, list):  
            yield from flatten(item)  # Рекурсивное "расплющивание" списка  
        else:  
            yield item  
  
  
nested_list = [1, [2, [3, 4], 5]]  
print(list(flatten(nested_list)))
```

```python
#!/usr/bin/env python3  
# countasync.py  
  
import asyncio  
  
  
async def count():  
    print("One")  
    await asyncio.sleep(1)  
    print("Two")  
  
  
async def main():  
    await asyncio.gather(count(), count(), count())  
  
  
if __name__ == "__main__":  
    import time  
  
    s = time.perf_counter()  
    asyncio.run(main())  
    elapsed = time.perf_counter() - s  
    print(f"(__file__) executed in {elapsed:0.2f} seconds.")
```


Есть генераторы, есть асинхронные генераторы, горутина не является генератором
